
----------------------------------------------------------------------------------------------------------------------------------------

TCP 和 UDP的区别
1.TCP是基于面向连接的，UDP是面向无连接的
2.TCP是基于流模式的，UDP是基于数据报
3.TCP能够保证数据的正确性，UDP不能。
4.TCP因为需要三次握手，四次挥手，所以效率慢，UDP快一点。

----------------------------------------------------------------------------------------------------------------------------------------

OSI七层模型

物理层→数据链路层→网络层→传输层→会话层→表示层→应用层

TCP/IP 四层模型

数据链路层（物理层+链路层）→网络层（网络层）→传输层（传输层）→应用层（会话层+表示层+应用层）

物理层：机械、电子、定时接口通信信道上的原始比特流传输。  （IEEE 802.11）
链路层：物理寻址，同时将原始的比特流转变为逻辑传输线路 
网络层：控制子网的运行，如逻辑编址、分组传输、路由选择 （IP，ICMP，ARP）
传输层：接受上一层的数据，在必要的时候把数据进行分割，并将这些数据交给网络层，且保证这些数据段有效到达对端。（TCP，UDP）
会话层：不同机器上的用户之间建立及管理会话    （SSL，TLS）
表示层：信息的语法语义以及他们之间的关联，如加密 解密，压缩解压缩（LPP轻量级表示协议）
应用层：各种应用程序的协议,如 HTTP,FTP,SMTP,POP3

----------------------------------------------------------------------------------------------------------------------------------------

TCP 三次握手和四次挥手

1.TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；
2.TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。
3.TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。
4.TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。
5.当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。 
 
四次挥手：

第一次挥手：
Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
第二次挥手：
Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。
第三次挥手：
Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
第四次挥手：
Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

----------------------------------------------------------------------------------------------------------------------------------------

为什么要进行三次握手呢（两次确认）？
   建立三次握手主要是因为A发送了再一次的确认，那么A为什么会再确认一次呢，主要是为了防止已失效的连接请求报文段又突然传送给B，从而产生了错误。
   
   所谓“已失效的连接请求报文”是这样产生的，正常情况下，A发出连接请求，但是因为连接报文请求丢失而未收到确认，于是A再重传一次连接请求，后来收到了请求，并收到了确认，建立了连接，数据传输完毕后，就释放链接，A共发送了两次连接请求报文段，其中第一个丢失，第二个到达了B，没有“已失效的连接请求报文段”，但是还有异常情况下，A发送的请求报文连接段并没有丢失，而是在某个网络节点滞留较长时间，以致延误到请求释放后的某个时间到达B，本来是一个早已失效的报文段，但是B收到了此失效连接请求报文段后，就误以为A又重新发送的连接请求报文段，并发送确认报文段给A，同意建立连接，如果没有三次握手，那么B发送确认后，连接就建立了，而此时A没有发送建立连接的请求报文段，于是不理会B的确认，也不会给B发送数据，而B却一直等待A发送数据，因此B的许多资源就浪费了，采用三次握手的方式就可以防止这种事情发生，例如刚刚，A不理会B，就不会给B发送确认，B收不到A的确认，就知道A不要求建立连接，就不会白白浪费资源，

----------------------------------------------------------------------------------------------------------------------------------------

为什么要进行四次挥手？

TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接

----------------------------------------------------------------------------------------------------------------------------------------

http协议状态码

1XX 信息性状态码
　　这些状态码是HTTP 1.1引入的。 对于这些状态码的价值还存在争论 （我个人从来没见过这些状态码， 也没有理解这些状态码。）
状态码	 状态消息	 含义	 实例
100	Continue(继续)	收到了请求的起始部分，客户端应该继续请求	 
101	Switching Protocols（切换协议）	服务器正根据客户端的指示将协议切换成Update Header列出的协议

2XX 成功状态码
　　客户端发起请求时， 这些请求通常都是成功的。服务器有一组用来表示成功的状态码，分别对应于不同类型的请求。
状态码	状态消息	含义	实例
200	OK	服务器成功处理了请求（这个是我们见到最多的）	 HTTP协议详解-200
201	Created（已创建）	对于那些要服务器创建对象的请求来说，资源已创建完毕。	 
202	Accepted（已接受）	请求已接受， 但服务器尚未处理	 
203	Non-Authoritative Information（非权威信息）	服务器已将事务成功处理，只是实体Header包含的信息不是来自原始服务器，而是来自资源的副本。	 
204	No Content(没有内容)	Response中包含一些Header和一个状态行， 但不包括实体的主题内容（没有response body）	 状态码204
205	Reset Content(重置内容)	 另一个主要用于浏览器的代码。意思是浏览器应该重置当前页面上所有的HTML表单。	 
206	Partial Content（部分内容）	 部分请求成功	 状态码206

3XX 重定向状态码
　重定向状态码用来告诉浏览器客户端，它们访问的资源已被移动， Web服务器发送一个重定向状态码和一个可选的Location Header, 告诉客户端新的资源地址在哪。
　浏览器客户端会自动用Location中提供的地址，重新发送新的Request。 这个过程对用户来说是透明的。
　301和302 非常相似，  一个是永久转移，一个是临时转移。   （在我们看来， 这两个没太大区别）
　302，303，307 是一样。  这是因为302是HTTP 1.0定义的， HTTP1.1中使用303,307. 同时又保留了302.  （但在现实中，我们还是用302，我是没见过303和307）
所以这一节， 我们只需要掌握302， 304 就可以了。
状态码	状态消息	含义	实例
300	Multiple Choices（多项选择）	 客户端请求了实际指向多个资源的URL。这个代码是和一个选项列表一起返回的，然后用户就可以选择他希望的选项了	 
301	Moved Permanently（永久移除)	请求的URL已移走。Response中应该包含一个Location URL, 说明资源现在所处的位置	状态码301
302	Found（已找到）	与状态码301类似。但这里的移除是临时的。 客户端会使用Location中给出的URL，重新发送新的HTTP request	HTTP协议详解-302
303	 See Other（参见其他）	类似302	 
304	Not Modified（未修改）	客户的缓存资源是最新的， 要客户端使用缓存	HTTP协议之缓存-304
305	 Use Proxy（使用代理）	必须通过代理访问资源， 代理的地址在Response 的Location中	 
306	 未使用	 这个状态码当前没使用	 
307	Temporary Redirect（临时重定向	类似302

4XX客户端错误状态码
　　有时客户端会发送一些服务器无法处理的东西，比如格式错误的Request, 或者最常见的是， 请求一个不存在的URL。
状态码	状态消息	含义	实例
400	Bad Request（坏请求）	告诉客户端，它发送了一个错误的请求。	状态码400
401	Unauthorized（未授权）	需要客户端对自己认证	HTTP协议之基本认证-401
402	Payment Required（要求付款）	这个状态还没被使用， 保留给将来用	 
403	Forbidden（禁止）	请求被服务器拒绝了	状态码403
404	Not Found（未找到）	未找到资源	HTTP协议详解-404
405	Method Not Allowed（不允许使用的方法）	不支持该Request的方法。	状态码405
406	Not Acceptable（无法接受）	 	 
407	Proxy Authentication Required(要求进行代理认证)	与状态码401类似， 用于需要进行认证的代理服务器	HTTP协议之代理-407
408	Request Timeout（请求超时）	 如果客户端完成请求时花费的时间太长， 服务器可以回送这个状态码并关闭连接	 
409	Conflict（冲突）	发出的请求在资源上造成了一些冲突	 
410	Gone（消失了）	服务器曾经有这个资源，现在没有了， 与状态码404类似	 
411	Length Required（要求长度指示）	服务器要求在Request中包含Content-Length。	状态码411
412	Precondition Failed（先决条件失败）	 	 
413	Request Entity Too Large（请求实体太大）	客户端发送的实体主体部分比服务器能够或者希望处理的要大	状态码413
414	Request URI Too Long（请求URI太长）	客户端发送的请求所携带的URL超过了服务器能够或者希望处理的长度	状态码414
415	Unsupported Media Type（不支持的媒体类型）	服务器无法理解或不支持客户端所发送的实体的内容类型	 
416	Requested Range Not Satisfiable（所请求的范围未得到满足）	 	 
417	Expectation Failed（无法满足期望）	

5XX服务器错误状态码
　　有时候客户端发送了一条有效Request, Web服务器自身却出错了。 可能是Web服务器运行出错了， 或者网站都挂了。  5XX就是用来描述服务器错误的。
状态码	状态消息	含义	实例
500	Internal Server Error(内部服务器错误)	服务器遇到一个错误，使其无法为请求提供服务	状态码500
501	Not Implemented（未实现）	客户端发起的请求超出服务器的能力范围(比如，使用了服务器不支持的请求方法)时，使用此状态码。	状态码501
502	Bad Gateway（网关故障）	代理使用的服务器遇到了上游的无效响应	状态码502
503	Service Unavailable（未提供此服务）	服务器目前无法为请求提供服务，但过一段时间就可以恢复服务	 
504	Gateway Timeout（网关超时）	与状态吗408类似， 但是响应来自网关或代理，此网关或代理在等待另一台服务器的响应时出现了超时	 
505	HTTP Version Not Supported（不支持的HTTP版本）	服务器收到的请求使用了它不支持的HTTP协议版本。 有些服务器不支持HTTP早期的HTTP协议版本，也不支持太高的协议版本	状态码505

----------------------------------------------------------------------------------------------------------------------------------------

cookie 和session区别

HTTP是一种无状态的协议，为了分辨链接是谁发起的，就需要我们自己去解决这个问题。不然有些情况下即使是同一个网站我们每打开一个页面也都要登录一下。而Session和Cookie就是为解决这个问题而提出来的两个机制。

cookie是服务器发送给客户端的数据，该数据会被保存在浏览器中，并且客户端的下一次请求报文会包含该cookie，通过cookie可以让服务器知道两个请求是否来自于同一个客户端，从而实现保持登录状态，因为Cookie存在客户端所以用户可以看见，所以也可以编辑伪造，不是十分安全。

session是存储在服务器端的，session会在一定时间内保存在服务器上.当访问增多,会比较占用你服务器的性能,如果主要考虑到减轻服务器性能方面,应当使用cookie

----------------------------------------------------------------------------------------------------------------------------------------

TCP滑动窗口控制流量的原理  https://www.cnblogs.com/luoquan/p/4886345.html

TCP的滑动窗口机制 
      TCP这个协议是网络中使用的比较广泛，他是一个面向连接的可靠的传输协议。既然是一个可靠的传输协议就需要对数据进行确认。TCP协议里窗口机制有2种：一种是固定的窗口大小；一种是滑动的窗口。这个窗口大小就是我们一次传输几个数据。对所有数据帧按顺序赋予编号，发送方在发送过程中始终保持着一个发送窗口，只有落在发送窗口内的帧才允许被发送；同时接收方也维持着一个接收窗口，只有落在接收窗口内的帧才允许接收。这样通过调整发送方窗口和接收方窗口的大小可以实现流量控制。
      TCP滑动窗口技术通过动态改变窗口大小来调节两台主机间数据传输。每个TCP/IP主机支持全双工数据传输，因此TCP有两个滑动窗口：一个用于接收数据，另一个用于发送数据。TCP使用肯定确认技术，其确认号指的是下一个所期待的字节。 假定发送方设备以每一次三个数据包的方式发送数据，也就是说，窗口大小为3。发送方发送序列号为1、2、3的三个数据包，接收方设备成功接收数据包，用序列号4确认。发送方设备收到确认，继续以窗口大小3发送数据。当接收方设备要求降低或者增大网络流量时，可以对窗口大小进行减小或者增加，本例降低窗口大小为2，每一次发送两个数据包。当接收方设备要求窗口大小为0，表明接收方已经接收了全部数据，或者接收方应用程序没有时间读取数据，要求暂停发送。发送方接收到携带窗口号为0的确认，停止这一方向的数据传输.
      
  实例：
      
首先是第一次发送数据这个时候的窗口大小是根据链路带宽的大小来决定的。我们假设这个时候窗口的大小是3。这个时候接受方收到数据以后会对数据进行确认告诉发送方我下次希望手到的是数据是多少。这里我们看到接收方发送的ACK=3(这是发送方发送序列2的回答确认，下一次接收方期望接收到的是3序列信号)。这个时候发送方收到这个数据以后就知道我第一次发送的3个数据对方只收到了2个。就知道第3个数据对方没有收到。下次在发送的时候就从第3个数据开始发。这个时候窗口大小就变成了2

----------------------------------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------------------------
