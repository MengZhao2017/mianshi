----------------------------------------------------------------------------------------------------------------------------------------
八种基本数据类型的大小，以及他们的封装类。

八种基本数据类型，int ,double ,long ,float, short,byte,character,boolean

对应的封装类型是：Integer ,Double ,Long ,Float, Short,Byte,Character,Boolean

----------------------------------------------------------------------------------------------------------------------------------------

Switch能否用string做参数？

在Java 5以前，switch(expr)中，expr只能是byte、short、char、int。从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型，从Java 7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。

----------------------------------------------------------------------------------------------------------------------------------------

equals与==的区别

==号在比较基本数据类型时比较的是值，而用==号比较两个对象时比较的是两个对象的地址值：

“==”或等号操作在Java编程语言中是一个二元操作符，用于比较原生类型和对象。就原生类型如boolean、int、float来说，使用“==”来比较两者，这个很好掌握。但是在比较对象的时候，就会与equals()造成困惑。“==”对比两个对象基于内存引用，如果两个对象的引用完全相同（指向同一个对象）时，“==”操作将返回true，否则返回false

主要区别在于前者是方法后者是操作符。“==”的行为对于每个对象来说与equals()是完全相同的，但是equals()可以基于业务规则的不同而重写（overridden )。“==”习惯用于原生（primitive）类型之间的比较，而equals()仅用于对象之间的比较。

==与equals的主要区别是：
1.==常用于比较原生类型，而equals()方法用于检查对象的相等性。
2.如果==和equals()用于比较对象，当两个引用地址相同，==返回true。而equals()可以返回true或者false主要取决于重写实现。最常见的一个例子，字符串的比较，不同情况==和equals()返回不同的结果。

----------------------------------------------------------------------------------------------------------------------------------------

object类中的方法？

1．clone方法

保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。

主要是JAVA里除了8种基本类型传参数是值传递，其他的类对象传参数都是引用传递，我们有时候不希望在方法里讲参数改变，这是就需要在类中复写clone方法。

2．getClass方法

final方法，获得运行时类型。

3．toString方法

该方法用得比较多，一般子类都有覆盖。

4．finalize方法

该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。

5．equals方法

该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。

6．hashCode方法

该方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。

一般必须满足obj1.equals(obj2)==true。可以推出obj1.hash- Code()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。

如果不重写hashcode(),在HashSet中添加两个equals的对象，会将两个对象都加入进去。

7．wait方法

wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。

调用该方法后当前线程进入睡眠状态，直到以下事件发生。

（1）其他线程调用了该对象的notify方法。

（2）其他线程调用了该对象的notifyAll方法。

（3）其他线程调用了interrupt中断该线程。

（4）时间间隔到了。

此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。

8．notify方法

该方法唤醒在该对象上等待的某个线程。

9．notifyAll方法

该方法唤醒在该对象上等待的所有线程。


----------------------------------------------------------------------------------------------------------------------------------------

Java的四种引用，强弱软虚，用到的场景。

JDK1.2之前只有强引用,其他几种引用都是在JDK1.2之后引入的.

强引用（Strong Reference） 最常用的引用类型，如Object obj = new Object(); 。只要强引用存在则GC时则必定不被回收。

软引用（Soft Reference） 用于描述还有用但非必须的对象，当堆将发生OOM（Out Of Memory）时则会回收软引用所指向的内存空间，若回收后依然空间不足才会抛出OOM。一般用于实现内存敏感的高速缓存。 当真正对象被标记finalizable以及的finalize()方法调用之后并且内存已经清理, 那么如果SoftReference object还存在就被加入到它的 ReferenceQueue.只有前面几步完成后,Soft Reference和Weak Reference的get方法才会返回null

弱引用（Weak Reference） 发生GC时必定回收弱引用指向的内存空间。 和软引用加入队列的时机相同

虚引用（Phantom Reference) 又称为幽灵引用或幻影引用，虚引用既不会影响对象的生命周期，也无法通过虚引用来获取对象实例，仅用于在发生GC时接收一个系统通知。 当一个对象的finalize方法已经被调用了之后，这个对象的幽灵引用会被加入到队列中。通过检查该队列里面的内容就知道一个对象是不是已经准备要被回收了. 虚引用和软引用和弱引用都不同,它会在内存没有清理的时候被加入引用队列.虚引用的建立必须要传入引用队列,其他可以没有


----------------------------------------------------------------------------------------------------------------------------------------

Hashcode的作用。

http://c610367182.iteye.com/blog/1930676

以Java.lang.Object来理解,JVM每new一个Object,它都会将这个Object丢到一个Hash哈希表中去,这样的话,下次做Object的比较或者取这个对象的时候,它会根据对象的hashcode再从Hash表中取这个对象。这样做的目的是提高取对象的效率。具体过程是这样:

new Object(),JVM根据这个对象的Hashcode值,放入到对应的Hash表对应的Key上,如果不同的对象确产生了相同的hash值,也就是发生了Hash key相同导致冲突的情况,那么就在这个Hash key的地方产生一个链表,将所有产生相同hashcode的对象放到这个单链表上去,串在一起。

比较两个对象的时候,首先根据他们的hashcode去hash表中找他的对象,当两个对象的hashcode相同,那么就是说他们这两个对象放在Hash表中的同一个key上,那么他们一定在这个key上的链表上。那么此时就只能根据Object的equal方法来比较这个对象是否equal。当两个对象的hashcode不同的话，肯定他们不能equal.

----------------------------------------------------------------------------------------------------------------------------------------

String、StringBuffer与StringBuilder的区别。

Java 平台提供了两种类型的字符串：String和StringBuffer / StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer和StringBulder类表示的字符串对象可以直接进行修改。StringBuilder是JDK1.5引入的，它和StringBuffer的方法完全相同，区别在于它是单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer略高。

----------------------------------------------------------------------------------------------------------------------------------------

Excption与Error区别

Error表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的状况；
Exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况

----------------------------------------------------------------------------------------------------------------------------------------


OOM：

1.OutOfMemoryError异常

除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(OOM)异常的可能，

Java Heap 溢出

一般的异常信息：java.lang.OutOfMemoryError:Java heap spacess

java堆用于存储对象实例，我们只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量达到最大堆容量限制后产生内存溢出异常。

出现这种异常，一般手段是先通过内存映像分析工具(如Eclipse Memory Analyzer)对dump出来的堆转存快照进行分析，重点是确认内存中的对象是否是必要的，先分清是因为内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)。

如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象时通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收。

如果不存在泄漏，那就应该检查虚拟机的参数(-Xmx与-Xms)的设置是否适当。

2.虚拟机栈和本地方法栈溢出

如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。

如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常

这里需要注意当栈的大小越大可分配的线程数就越少。

3.运行时常量池溢出

异常信息：java.lang.OutOfMemoryError:PermGen space

如果要向运行时常量池中添加内容，最简单的做法就是使用String.intern()这个Native方法。该方法的作用是：如果池中已经包含一个等于此String的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。由于常量池分配在方法区内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区的大小，从而间接限制其中常量池的容量。

4.方法区溢出

方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。

异常信息：java.lang.OutOfMemoryError:PermGen space

方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，判定条件是很苛刻的。在经常动态生成大量Class的应用中，要特别注意这点。

----------------------------------------------------------------------------------------------------------------------------------------

Java面向对象的三个特征与含义。

继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。

封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。

多态：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1. 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2. 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。

----------------------------------------------------------------------------------------------------------------------------------------

Interface与abstract类的区别。

抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。

----------------------------------------------------------------------------------------------------------------------------------------

反射机制

JAVA反射机制是在运行状态中, 对于任意一个类, 都能够知道这个类的所有属性和方法; 对于任意一个对象, 都能够调用它的任意一个方法和属性; 这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制.

主要作用有三：

运行时取得类的方法和字段的相关信息。

创建某个类的新实例(.newInstance())

取得字段引用直接获取和设置对象字段，无论访问修饰符是什么。

用处如下：

观察或操作应用程序的运行时行为。

调试或测试程序，因为可以直接访问方法、构造函数和成员字段。

通过名字调用不知道的方法并使用该信息来创建对象和调用方法。

----------------------------------------------------------------------------------------------------------------------------------------

泛型的优缺点

优点：

使用泛型类型可以最大限度地重用代码、保护类型的安全以及提高性能。

泛型最常见的用途是创建集合类。

缺点：

在性能上不如数组快。

----------------------------------------------------------------------------------------------------------------------------------------

ArrayList、LinkedList、Vector的底层实现和区别

1.从同步性来看，ArrayList和LinkedList是不同步的，而Vector是的。所以线程安全的话，可以使用ArrayList或LinkedList，可以节省为同步而耗费的开销。但在多线程下，有时候就不得不使用Vector了。当然，也可以通过一些办法包装ArrayList、LinkedList，使我们也达到同步，但效率可能会有所降低。

2.从内部实现机制来讲ArrayList和Vector都是使用Object的数组形式来存储的。当你向这两种类型中增加元素的时候，如果元素的数目超出了内部数组目前的长度它们都需要扩展内部数组的长度，Vector缺省情况下自动增长原来一倍的数组长度，ArrayList是原来的50%，所以最后你获得的这个集合所占的空间总是比你实际需要的要大。如果你要在集合中保存大量的数据，那么使用Vector有一些优势，因为你可以通过设置集合的初始化大小来避免不必要的资源开销。

3.ArrayList和Vector中，从指定的位置（用index）检索一个对象，或在集合的末尾插入、删除一个对象的时间是一样的，可表示为O(1)。但是，如果在集合的其他位置增加或者删除元素那么花费的时间会呈线性增长O(n-i)，其中n代表集合中元素的个数，i代表元素增加或移除元素的索引位置，因为在进行上述操作的时候集合中第i和第i个元素之后的所有元素都要执行(n-i)个对象的位移操作。LinkedList底层是由双向循环链表实现的，LinkedList在插入、删除集合中任何位置的元素所花费的时间都是一样的O(1)，但它在索引一个元素的时候比较慢，为O(i)，其中i是索引的位置，如果只是查找特定位置的元素或只在集合的末端增加、移除元素，那么使用Vector或ArrayList都可以。如果是对其它指定位置的插入、删除操作，最好选择LinkedList。

----------------------------------------------------------------------------------------------------------------------------------------


HashMap和HashTable的底层实现和区别，两者和ConcurrentHashMap的区别。

http://blog.csdn.net/xuefeng0707/article/details/40834595

HashTable线程安全则是依靠方法简单粗暴的sychronized修饰，HashMap则没有相关的线程安全问题考虑。。

在以前的版本貌似ConcurrentHashMap引入了一个“分段锁”的概念，具体可以理解为把一个大的Map拆分成N个小的HashTable，根据key.hashCode()来决定把key放到哪个HashTable中。在ConcurrentHashMap中，就是把Map分成了N个Segment，put和get的时候，都是现根据key.hashCode()算出放到哪个Segment中。

通过把整个Map分为N个Segment（类似HashTable），可以提供相同的线程安全，但是效率提升N倍。

----------------------------------------------------------------------------------------------------------------------------------------

Map、Set、List、Queue、Stack的特点与用法。

http://www.cnblogs.com/yumo/p/4908718.html

Collection 是对象集合， Collection 有两个子接口 List 和 Set

List 可以通过下标 (1,2..) 来取得值，值可以重复

而 Set 只能通过游标来取值，并且值是不能重复的

ArrayList ， Vector ， LinkedList 是 List 的实现类

ArrayList 是线程不安全的， Vector 是线程安全的，这两个类底层都是由数组实现的

LinkedList 是线程不安全的，底层是由链表实现的

Map 是键值对集合

HashTable 和 HashMap 是 Map 的实现类
HashTable 是线程安全的，不能存储 null 值
HashMap 不是线程安全的，可以存储 null 值

Stack类：继承自Vector，实现一个后进先出的栈。提供了几个基本方法，push、pop、peak、empty、search等。

Queue接口：提供了几个基本方法，offer、poll、peek等。已知实现类有LinkedList、PriorityQueue等。

----------------------------------------------------------------------------------------------------------------------------------------

Synchronized 和Lock的区别

1.synchronized是关键字，lock是接口
2.Synchronized发生异常时，会自动释放县城占有的锁，不会发生死锁。lock发生异常时，若没有主动通过unlock()释放锁，很可能发生死锁，所以使用lock的时候，要在finally中释放锁。
3.lock可以知道是否成功获得锁，s不行。

----------------------------------------------------------------------------------------------------------------------------------------
Synchronized和volatile的区别

1.V本质是告诉jvm当前变量在工作内存中的值是不确定的，需要从主存中获取，而S是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞。
2.V仅能使用在变量级别，而S这可以使用在变量、方法、类级别中。
3.V不会造成线程阻塞，S会造成线程阻塞。

----------------------------------------------------------------------------------------------------------------------------------------

hashmap实现原理

1.数组+链表+红黑树
2.数组的初始大小是16，最大值是2的30次方，扩容因子：0.75
3.链表的初始大小是8，即：当链表的大小达到8的时候，会自动转为红黑树的结构，目的是为了方便查找，在lgn的复杂度内
4.数组的初始大小是16，当当前的数据>16*0.75=12的时候，就会调用resize()的方法进行二倍的扩容（newCap=oldCap<<1）,将原来旧数组中的直接放在新数组中的对应位置 即newTab[j+oldCap]=hHead;


说一下put()的原理？

当我们使用put()的时候，会调用putVal(Hash(key),key,value,...)
1.先根据key计算hash值，这里这样计算的，int h;(int 类型是32位)，return (key==null)?0:(h=key.hashcode())^(h>>>16)
 这里注意一下：最后为什么要向右移16位，而不是直接计算hashcode值？
 首先我们计算得到的hashcode值是非常大的，而我们的数组不会是那么大的
 其次，向右移动16位，原先的int类型的是32位，右移16位后，32位的16个低位就没有了，这个时候，在用完整的hash跟剩下的高位16位进行异或能够充分利用高低位来计算，，然后达到缩小范围，使其尽可能分散，不集中，避免hash碰撞。
 
 2.把得到的hash值传入putVal()中
    a.首先判断Tab数组是不是空→resize()→不是进行扩容，而是进行数组的初始化16
    b.根据hash值判断在数组中的位置，通过Tab[i=(n-1)&hash]
    注意这里获取地址是通过与运算，而不是直接的取模求余，为什么？
    其实这里面的(n-1)&hash  =   hash %n,之所以这么写，是因为位运算更快。
    n-1 也是有很大的学问？数组的长度都是2的n次幂，那么气二进制表示一定是10000000...这样类型的，那么n-1就会出现01111111....这样类型的
    然后与hash进行&运算，就会得到<=数组的长度
 3.当不断向里面put的时候，当链表中元素的个数>8的时候，就会自动转为红黑树的存储，当我们不断的去除结点，当红黑树的节点数<6的时候，就又会转为链表形式。
 
----------------------------------------------------------------------------------------------------------------------------------------
如何实现Arraylist的add方法，插入时数组满了怎么办，扩容的话新数组是多大?

ArrayList是基于数组实现的，新增元素默认添加到数组的尾部，插入时数组满了会自动扩容，新数组是旧数组的1.5倍。
下面为addd（）方法的源码，其中size指的是数组中存放元素的个数，elementData.length表示数组的长度，当new一个ArrayList系统默认产生一个长度为10的elementData数组，elementData.length=10，但是由于elementData中还未放任何元素所有size=0。如果加入元素后数组大小不够会先进行扩容，每次扩容都将数组大小增大一半，比如数组大小为10一次扩容后的大小为10+5=10;ArrayList的最大长度为 2^32 

----------------------------------------------------------------------------------------------------------------------------------------

JVM内存模型，内存中有什么?

内存中分为5个部分，其中线程私有的是程序计数器，java虚拟栈，本地方法栈，共享的是堆和方法区。

程序计数器 ：多线程时，当线程数超过CPU数量或CPU内核数量，线程之间就要根据时间片轮询抢夺CPU时间资源。因此每个线程有要有一个独立的程序计数器，记录下一条要运行的指令。线程私有的内存区域。如果执行的是JAVA方法，计数器记录正在执行的java字节码地址，如果执行的是native方法，则计数器为空。

虚拟机栈： 线程私有的，与线程在同一时间创建。管理JAVA方法执行的内存模型。每个方法执行时都会创建一个桢栈来存储方法的的变量表、操作数栈、动态链接方法、返回值、返回地址等信息。栈的大小决定了方法调用的可达深度（递归多少层次，或嵌套调用多少层其他方法，-Xss参数可以设置虚拟机栈大小）。栈的大小可以是固定的，或者是动态扩展的。如果请求的栈深度大于最大可用深度，则抛出stackOverflowError；如果栈是可动态扩展的，但没有内存空间支持扩展，则抛出OutofMemoryError。

本地方法区： 和虚拟机栈功能相似，但管理的不是JAVA方法，是本地方法，本地方法是用C实现的。

JAVA堆： 线程共享的，存放所有对象实例和数组。垃圾回收的主要区域。可以分为新生代和老年代(tenured)。
新生代用于存放刚创建的对象以及年轻的对象，如果对象一直没有被回收，生存得足够长，年轻对象就会被移入老年代。
新生代又可进一步细分为eden、survivorSpace0(s0,from space)、survivorSpace1(s1,to
space)。刚创建的对象都放入eden,s0和s1都至少经过一次GC并幸存。如果幸存对象经过一定时间仍存在，则进入老年代(tenured)。

方法区： 线程共享的，用于存放被虚拟机加载的类的元数据信息：如常量、静态变量、即时编译器编译后的代码。也成为永久代。如果hotspot虚拟机确定一个类的定义信息不会被使用，也会将其回收。回收的基本条件至少有：所有该类的实例被回收，而且装载该类的ClassLoader被回收

----------------------------------------------------------------------------------------------------------------------------------------

ConcurrentHashMap的设计原理？https://blog.csdn.net/zlfprogram/article/details/77524326

ConcurrentHashMap采用了分段锁的设计，只有在同一个分段内才存在竞态关系，不同的分段锁之间没有锁竞争。相比于对整个Map加锁的设计，分段锁大大的提高了高并发环境下的处理能力
ConcurrentHashMap中对这个数据结构，针对并发稍微做了一点调整。
它把区间按照并发级别(concurrentLevel)，分成了若干个segment。默认情况下内部按并发级别为16来创建。对于每个segment的容量，默认情况也是16。当然并发级别(concurrentLevel)和每个段(segment)的初始容量都是可以通过构造函数设定的。

![](https://github.com/MengZhao2017/mianshi/raw/master/res/Q137.png)

----------------------------------------------------------------------------------------------------------------------------------------

进程和线程

1、进程是什么？
是具有一定独立功能的程序、它是系统进行资源分配和调度的一个独立单位，重点在系统调度和单独的单位，也就是说进程是可以独 立运行的一段程序。
2、线程又是什么？
线程是进程的一个实体，是CPU调度和分派的基本单位，他是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源。
在运行时，只是暂用一些计数器、寄存器和栈 。

他们之间的关系

1、一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程（通常说的主线程）。
2、资源分配给进程，同一进程的所有线程共享该进程的所有资源。
3、线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。
4、处理机分给线程，即真正在处理机上运行的是线程。
5、线程是指进程内的一个执行单元，也是进程内的可调度实体。 

从三个角度来剖析二者之间的区别
1、调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。
2、并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行。
3、拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。

----------------------------------------------------------------------------------------------------------------------------------------

java进程之间通信方式?
（1）管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。

（2）命名管道（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关 系 进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。

（3）信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送 信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。

（4）消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺

（5）共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。

（6）内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。

（7）信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。

（8）套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。

----------------------------------------------------------------------------------------------------------------------------------------

java线程之间通信方式？https://blog.csdn.net/ls5718/article/details/51878770

1、共享变量

线程间发送信号的一个简单方式是在共享对象的变量里设置信号值。线程A在一个同步块里设置boolean型成员变量hasDataToProcess为true，线程B也在同步块里读取hasDataToProcess这个成员变量。这个简单的例子使用了一个持有信号的对象，并提供了set和check方法:

2、wait/notify机制

为了实现线程通信，我们可以使用Object类提供的wait()、notify()、notifyAll()三个方法。调用wait()方法会释放对该同步监视器的锁定。这三个方法必须由同步监视器对象来调用，这可分成两种情况：
对于使用synchronized修饰的同步方法，因为该类的默认实例是(this)就是同步监视器，所以可以直接调用这三使用个方法。
对于synchronized修饰的同步代码块，同步监视器是synchronized括号里的对象，所以必须使用该对象调用这三个方法。

3、Lock/Condition机制

如何程序不使用synchronized关键字来保持同步，而是直接适用Lock对像来保持同步，则系统中不存在隐式的同步监视器对象，也就不能使用wait()、notify()、notifyAll()来协调线程的运行.
当使用LOCK对象保持同步时，JAVA为我们提供了Condition类来协调线程的运行。关于Condition类，JDK文档里进行了详细的解释.，再次就不啰嗦了。

4、管道

管道流是JAVA中线程通讯的常用方式之一，基本流程如下：

1）创建管道输出流PipedOutputStream pos和管道输入流PipedInputStream pis

2）将pos和pis匹配，pos.connect(pis);

3）将pos赋给信息输入线程，pis赋给信息获取线程，就可以实现线程间的通讯了


----------------------------------------------------------------------------------------------------------------------------------------

get和post的区别

1.get是从服务器上获取数据，post是向服务器传送数据
2.get是吧参数放在URL中，post是把参数放在http包体内
3.get传送的数据量较小，不能大于2kb，post较大，一般不受限制
4.get效率高，安全性低，post相反

----------------------------------------------------------------------------------------------------------------------------------------

java的单例模式
懒汉：
       public class Singleton{
       
       private static Singleton s;
       private Singleton(){};
       public static sychronized Singleton getS()
       {
            if(s==null)
            {
              s=new Singleton();
            }
            return s;
       }
       }
       
饿汉：
       public class Singleton{

              private static final Singleton s=new Singleton();
              private Singleton(){};
              public static  Singleton getS()
              {
                   return s;
              }
              }

----------------------------------------------------------------------------------------------------------------------------------------

sleep和wait区别

1.sleep是Thread的类方法，wait是object类
2.sleep是自动唤醒，wait要等待其他线程来唤醒
3.sleep不会释放同步锁，wait会释放
4.sleep可以在任意方法中，wait只能在同步块中

----------------------------------------------------------------------------------------------------------------------------------------

死锁产生的必要条件

1.互斥条件：同一时间，某个资源只能由一个进程占用
2.占有并等待
3.不可剥夺： 未使用完成前，不能被剥夺
4.环路等待

处理死锁的方法：
1.预防死锁
2.避免死锁
3.检测死锁
4.解除死锁


----------------------------------------------------------------------------------------------------------------------------------------

ThreadLocal 原理介绍：https://blog.csdn.net/mccand1234/article/details/54173084

ThreadLocal是什么
ThreadLocal是一个关于创建线程局部变量的类。
通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。而使用ThreadLocal创建的变量只能被当前线程访问，其他线程则无法访问和修改。

就是为每一个使用该变量的线程都提供一个变量值的副本，是每一个线程都可以独立改变自己的副本，而不会和其他线程的副本产生冲突

ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。

可以总结为一句话：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。 
举个例子，我出门需要先坐公交再做地铁，这里的坐公交和坐地铁就好比是同一个线程内的两个函数，我就是一个线程，我要完成这两个函数都需要同一个东西：公交卡（北京公交和地铁都使用公交卡），那么我为了不向这两个函数都传递公交卡这个变量（相当于不是一直带着公交卡上路），我可以这么做：将公交卡事先交给一个机构，当我需要刷卡的时候再向这个机构要公交卡（当然每次拿的都是同一张公交卡）。这样就能达到只要是我(同一个线程)需要公交卡，何时何地都能向这个机构要的目的。

public T get() { }
public void set(T value) { }
public void remove() { }
protected T initialValue() { }
get()方法是用来获取ThreadLocal在当前线程中保存的变量副本，set()用来设置当前线程中变量的副本，remove()用来移除当前线程中变量的副本，initialValue()是一个protected方法，一般是用来在使用时进行重写的，它是一个延迟加载方法，下面会详细说明。

----------------------------------------------------------------------------------------------------------------------------------------

ThreadLocal 与synchronized对比：

1.都是解决线程同步问题

2.synchronized修饰：线程将排队访问变量，以时间换空间；threadloca修饰：会为每个线程创建一个副本，以空间换时间

3.synchronized修饰:每个线程的调用后对变量的修改都是有影响的；threadloca修饰：线程之间对变量的修改互不影响，各自持有变量的副本

----------------------------------------------------------------------------------------------------------------------------------------

volatile关键字剖析？

volatile关键字的两层语义

一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：

1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。

2）禁止进行指令重排序。

     volatile关键字禁止指令重排序有两层意思：
       1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；

       2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。


----------------------------------------------------------------------------------------------------------------------------------------

java内存模型概述

JMM本身是一种抽象的概念，并不是真实存在的，它描述的是一种规则或者规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和数组）的访问方式，由于jvm运行程序的实体是线程，而每个线程创建时jvm都会为其创建一个工作内存，用于存储线程的私有数据，而java内存模型规定所有变量都必须存在主内存，主内存是共享内存区域，所有线程都可以进行访问，但线程对变量的操作（读取 赋值等）必须在工作内存中完成。
首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后，再将变量写回主内存，不能直接操作主内存中的变量，工作内存存储着主内存中的变量拷贝副本。

----------------------------------------------------------------------------------------------------------------------------------------

为什么一般重写equals()的时候，要重写hashcode()?


1.若重写了equals()但未重写hashCode(),会违反约定：相等的对象必须要有相同的散列码（hashcode）。

2.对于基于hash实现的类，如HashSet，HashMap，若不重写hashCode()，会导致这些类不能正常使用。原因是：HashMap底层是数组，其下标是传入元素的hashCode和特定值异或决定的。若该数组位置上有值且键值相等，则不处理；若不等则覆盖；若该位置为空，则插入并加入到响应链表中。检查键是否存在也是由hashCode值确定的

----------------------------------------------------------------------------------------------------------------------------------------

java 中线程池

线程池：在程序启动的时候就创建若干线程来响应处理。池里存放的是工作线程。

作用：一.降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
     二.提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
     三.提高线程的可管理性。
常用线程池：ExecutorService 是主要的实现类，其中常用的有 :
Executors.newSingleThreadPool()

newFixedThreadPool()

newcachedTheadPool()

newScheduledThreadPool()

----------------------------------------------------------------------------------------------------------------------------------------

java 中泛型  https://blog.csdn.net/sunxianghuang/article/details/51982979

1. Java中的泛型是什么 ? 使用泛型的好处是什么?

泛型是一种参数化类型的机制。它可以使得代码适用于各种类型，从而编写更加通用的代码，例如集合框架

泛型是一种编译时类型确认机制。它提供了编译期的类型安全，确保在泛型类型（通常为泛型集合）上只能使用正确类型的对象，避免了在运行时出现ClassCastException。

主要优点：是能够在编译时而不是在运行时检测出错误。

举个例子：
Comparable  c=new Date();
System.out.println(c.compareTo("red"));//这样的代码是可以编译的，但是会产生一个运行时的错误。因为字符串不可能和Data对象进行比较

Comparable <Data>  c=new Date();
System.out.println(c.compareTo("red"));//这样的代码在编译的时候就会出现错误，因此泛型是程序更加可靠。
 
 泛型类型必须是引用类型，不能使用int，double或者char这样的基本类型，应该是Integer，Double，Character等

2.Java的泛型是如何工作的 ? 什么是类型擦除 ?

泛型的正常工作是依赖编译器在编译源码的时候，先进行类型检查，然后进行类型擦除并且在类型参数出现的地方插入强制转换的相关指令实现的。

编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如List<String>在运行时仅用一个List类型来表示。为什么要进行擦除呢？这是为了避免类型膨胀。

3. 什么是泛型中的限定通配符和非限定通配符 ?

限定通配符对类型进行了限制。有两种限定通配符，一种是<? extends T>它通过确保类型必须是T的子类来设定类型的上界，另一种是<? super T>它通过确保类型必须是T的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面<?>表示了非限定通配符，因为<?>可以用任意类型来替代。

4. List<? extends T>和List <? super T>之间有什么区别 ?

这和上一个面试题有联系，有时面试官会用这个问题来评估你对泛型的理解，而不是直接问你什么是限定通配符和非限定通配符。这两个List的声明都是限定通配符的例子，List<? extends T>可以接受任何继承自T的类型的List，而List<? super T>可以接受任何T的父类构成的List。例如List<? extends Number>可以接受List<Integer>或List<Float>。在本段出现的连接中可以找到更多信息。
 
 5.Java中List<?>和List<Object>之间的区别是什么?
 
这道题跟上一道题看起来很像，实质上却完全不同。List<?> 是一个未知类型的List，而List<Object>其实是任意类型的List。你可以把List<String>, List<Integer>赋值给List<?>，却不能把List<String>赋值给List<Object>。   

----------------------------------------------------------------------------------------------------------------------------------------

Java是如何实现跨平台的？

跨平台是怎样实现的呢？这就要谈及Java虚拟机（Java Virtual Machine，简称 JVM）。

JVM也是一个软件，不同的平台有不同的版本。我们编写的Java源码，编译后会生成一种 .class 文件，称为字节码文件。Java虚拟机就是负责将字节码文件翻译成特定平台下的机器码然后运行。也就是说，只要在不同平台上安装对应的JVM，就可以运行字节码文件，运行我们编写的Java程序。

而这个过程中，我们编写的Java程序没有做任何改变，仅仅是通过JVM这一”中间层“，就能在不同平台上运行，真正实现了”一次编译，到处运行“的目的。
JVM是一个”桥梁“，是一个”中间件“，是实现跨平台的关键，Java代码首先被编译成字节码文件，再由JVM将字节码文件翻译成机器语言，从而达到运行Java程序的目的。
注意：编译的结果不是生成机器码，而是生成字节码，字节码不能直接运行，必须通过JVM翻译成机器码才能运行。不同平台下编译生成的字节码是一样的，但是由JVM翻译成的机器码却不一样。

所以，运行Java程序必须有JVM的支持，因为编译的结果不是机器码，必须要经过JVM的再次翻译才能执行。即使你将Java程序打包成可执行文件（例如 .exe），仍然需要JVM的支持。

注意：跨平台的是Java程序，不是JVM。JVM是用C/C++开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的JVM。

----------------------------------------------------------------------------------------------------------------------------------------

手机扫二维码登录是怎么实现的？ https://www.jianshu.com/p/7f072ac61763

①：用户 A 访问微信网页版，微信服务器为这个会话生成一个全局唯一的 ID，上面的 URL 中 obsbQ-Dzag== 就是这个 ID，此时系统并不知道访问者是谁。

②：用户A打开自己的手机微信并扫描这个二维码，并提示用户是否确认登录。

③：手机上的微信是登录状态，用户点击确认登录后，手机上的微信客户端将微信账号和这个扫描得到的 ID 一起提交到服务器

④：服务器将这个 ID 和用户 A 的微信号绑定在一起，并通知网页版微信，这个 ID 对应的微信号为用户 A，网页版微信加载用户 A 的微信信息，至此，扫码登录全部流程完成

----------------------------------------------------------------------------------------------------------------------------------------

Java 线程有哪些状态，这些状态之间是如何转化的？

新建(new)：新创建了一个线程对象。

可运行(runnable)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。

运行(running)：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。

阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种：

(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。

(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。

(三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。

死亡(dead)：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。

当然有的时候也会说七种状态，那就是除了上面的五种状态外，再加上等待队列（等待阻塞）、和锁池（同步阻塞）。

----------------------------------------------------------------------------------------------------------------------------------------

通过反射机制获取类对象方法与区别

1.Class c1=Class.forName("cn.test.Demo");

2.Class c2=Demo.class;

3.Class c3=new Demo().getClass();

区别：

c1 方式会让 ClassLoader 进行类加载然后进行类的初始化。

c2 方式会让 ClassLoader 进行类加载但是不初始化。

c3 方式获取的是已经被加载且初始化过后实例化运行中类的 Class 实例。

简单说说 Java Class.newInstance() 与 Constructor.newInstance() 方法区别？

调用 Class 对象的 newInstance 方法会调用对象的默认构造方法，如果没有默认构造方法就会异常调用失败。而调用 Constructor 对象的 newInstance 方法可以选择要不要传递参数，没有参数时就类似 Class 的 newInstance，有参数时就调用对应有参构造方法。

----------------------------------------------------------------------------------------------------------------------------------------

ReentrantLock:

ReentrantLock→Lock
ReentrantLocky 拥有与 Synchronized相同的并发性和内存语义，但是添加了类似的锁投票，定时锁等候和可中断锁等候的一些特性。

1.Synchronized只支持单条件，比如10个线程都在等候Synchronized块锁定的资源，如果一直锁定，则其他线程都得不到释放而引起死锁，同样情况下，ReentrantLock则允许其他线程中断放弃尝试，可以指定notify某个线程。

2.ReentrantLock可以成为公平锁，即让等待最长时间的线程最早获得该锁，（获得锁的顺序和申请锁的顺序是一致的），与之对应的Synchronized是非公平的，当然ReentrantLock也可以是非公平的。

3.ReentrantLock又叫可重入锁，也就是说一个线程拥有锁之后，可以再次确认是否持有锁而不会出现死锁问题。

Synchronized是依赖于JVM实现的，而ReenTrantLock是JDK实现的，有什么区别，说白了就类似于操作系统来控制实现和用户自己敲代码实现的区别。前者的实现是比较难见到的，后者有直接的源码可供阅读。

ReenTrantLock独有的能力：

1.      ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。

2.      ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。

3.      ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。

----------------------------------------------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------------------------------------------



















