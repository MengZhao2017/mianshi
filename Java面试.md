---------------------------------------------------------------------------------------------------------------------------------------
BIO、NIO的源码分析：

当我们客户端向server发出请求的时候，也就是Socket通信的时候，然后server接受到accept后就会进行IO操作

BIO意思是阻塞式IO操作：阻塞？阻塞在什么位置呢？下图红箭头的位置。如下图所示：
![](https://github.com/MengZhao2017/mianshi/raw/master/res/NIO1.png)

1.在server端监听的时候，会发生阻塞，有客户端请求的时候接受客户端的请求，没有客户端请求的时候就会发生阻塞。

2.在server接收到请求后，进行IO操作的时候，只能进行单方面的操作，即：读没有完成是不可能进行写操作的，发生了阻塞。

所以就有人想到，既然2 会发生阻塞（主要原因单线程），那么你有多少个请求，我们就给你开多少个线程来处理，如下图所示：

![](https://github.com/MengZhao2017/mianshi/raw/master/res/NIO2.png)

但是这时候会出现一个问题，就是线程的创建和切换是非常浪费时间和系统资源，所以又会想到java里的线程池问题，事先创建一个线程池，这样就能有效减少创建和切换时候发生的浪费问题。如下图所示：
![](https://github.com/MengZhao2017/mianshi/raw/master/res/NIO3.png)

所以通过BIO我们能解决掉IO操作阻塞的问题
可以发现BIO其实就是 你来一个请求Socket，我都会给你一个执行线程，这样就会出现服务器端线程数量太多，线程数太多就会出现问题，CPU任务调度之间的性能消耗还有人物之间的切换都会导致性能下降。

那怎么既满足不阻塞又能保证性能呢？NIO就应运而生了。如下图所示：

![](https://github.com/MengZhao2017/mianshi/raw/master/res/NIO4.png)

NIO分为三个部分：Channel、Selector、Buffer

Channel：是客户端向服务器端的一个来回通道，双向的。之前的是请求是，请求完成后就直接撤销了，在用到的时候再次请求，浪费资源。

通道是一种途径,借助该途径,可以用最小的总开销来访问操作系统本身的 I/O 服务

Selector：是一个选择器。

Buffer：是一个缓冲区。为什么说NIO是基于缓冲区的IO方式呢？因为，当一个链接建立完成后，IO的数据未必会马上到达，为了当数据到达时能够正确完成IO操作，在BIO（阻塞IO）中，等待IO的线程必须被阻塞，以全天候地执行IO操作。为了解决这种IO方式低效的问题，引入了缓冲区的概念，当数据到达时，可以预先被写入缓冲区，再由缓冲区交给线程，因此线程无需阻塞地等待IO。

底层是一个数组实现，里面包含：position（位置），capacity（数组大小），Mark=-1（开始标志位），limit（限制的位置）

容量（Capacity）：缓冲区能够容纳的数据元素的最大数量。这一个容量在缓冲区创建时被设定，并且永远不能改变。

上界(Limit)：缓冲区的第一个不能被读或写的元素。或者说,缓冲区中现存元素的计数。

位置(Position)：下一个要被读或写的元素的索引。位置会自动由相应的 get( )和 put( )函数更新。

标记(Mark)：下一个要被读或写的元素的索引。位置会自动由相应的 get( )和 put( )函数更新



工作流程是：当多个客户端向服务器通过channel发送请求的时候，这个时候不是直接给你分配可执行线程（BIO是的），这里面多了一步，就是你来了很多的请求socket，Selector 代替了线程本身轮询 IO 事件，避免了阻塞同时减少了不必要的线程消耗，使用select（）直接进行注册而不是直接给你执行线程，执行select()后，也就意味客户端和服务端链接成功了，状态变为connected，这个时候会监听这个请求是不是要进行IO操作，如果是IO操作，把状态connected转变为Readable或者writeable，这个时候再给其分配一个可执行线程，这就区别开了BIO，无论是不是IO操作请求我都给你分配一个可执行线程，有效减少线程数量。




---------------------------------------------------------------------------------------------------------------------------------------

Java线程状态转换图：

![](https://github.com/MengZhao2017/mianshi/raw/master/res/ThreadToState.jpg)

----------------------------------------------------------------------------------------------------------------------------------------
#### 八种基本数据类型的大小，以及他们的封装类。

八种基本数据类型，int ,double ,long ,float, short,byte,character,boolean

对应的封装类型是：Integer ,Double ,Long ,Float, Short,Byte,Character,Boolean

----------------------------------------------------------------------------------------------------------------------------------------

#### Switch能否用string做参数？

在Java 5以前，switch(expr)中，expr只能是byte、short、char、int。从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型，从Java 7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。

----------------------------------------------------------------------------------------------------------------------------------------

#### equals与==的区别

==号在比较基本数据类型时比较的是值，而用==号比较两个对象时比较的是两个对象的地址值：

“==”或等号操作在Java编程语言中是一个二元操作符，用于比较原生类型和对象。就原生类型如boolean、int、float来说，使用“==”来比较两者，这个很好掌握。但是在比较对象的时候，就会与equals()造成困惑。“==”对比两个对象基于内存引用，如果两个对象的引用完全相同（指向同一个对象）时，“==”操作将返回true，否则返回false

主要区别在于前者是方法后者是操作符。“==”的行为对于每个对象来说与equals()是完全相同的，但是equals()可以基于业务规则的不同而重写（overridden )。“==”习惯用于原生（primitive）类型之间的比较，而equals()仅用于对象之间的比较。

==与equals的主要区别是：
1.==常用于比较原生类型，而equals()方法用于检查对象的相等性。
2.如果==和equals()用于比较对象，当两个引用地址相同，==返回true。而equals()可以返回true或者false主要取决于重写实现。最常见的一个例子，字符串的比较，不同情况==和equals()返回不同的结果。

----------------------------------------------------------------------------------------------------------------------------------------

#### object类中的方法？

1．clone方法

保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。

主要是JAVA里除了8种基本类型传参数是值传递，其他的类对象传参数都是引用传递，我们有时候不希望在方法里讲参数改变，这是就需要在类中复写clone方法。

2．getClass方法

final方法，获得运行时类型。

3．toString方法

该方法用得比较多，一般子类都有覆盖。

4．finalize方法

该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。

5．equals方法

该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。

6．hashCode方法

该方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。

一般必须满足obj1.equals(obj2)==true。可以推出obj1.hash- Code()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。

如果不重写hashcode(),在HashSet中添加两个equals的对象，会将两个对象都加入进去。

7．wait方法

wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。

调用该方法后当前线程进入睡眠状态，直到以下事件发生。

（1）其他线程调用了该对象的notify方法。

（2）其他线程调用了该对象的notifyAll方法。

（3）其他线程调用了interrupt中断该线程。

（4）时间间隔到了。

此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。

8．notify方法

该方法唤醒在该对象上等待的某个线程。

9．notifyAll方法

该方法唤醒在该对象上等待的所有线程。


----------------------------------------------------------------------------------------------------------------------------------------

#### Java的四种引用，强弱软虚，用到的场景。

JDK1.2之前只有强引用,其他几种引用都是在JDK1.2之后引入的.

强引用（Strong Reference） 最常用的引用类型，如Object obj = new Object(); 。只要强引用存在则GC时则必定不被回收。

软引用（Soft Reference） 用于描述还有用但非必须的对象，当堆将发生OOM（Out Of Memory）时则会回收软引用所指向的内存空间，若回收后依然空间不足才会抛出OOM。一般用于实现内存敏感的高速缓存。 当真正对象被标记finalizable以及的finalize()方法调用之后并且内存已经清理, 那么如果SoftReference object还存在就被加入到它的 ReferenceQueue.只有前面几步完成后,Soft Reference和Weak Reference的get方法才会返回null

使用场景：

在我们使用浏览器的时候，按下back键的时候，是重新向服务器请求，还是直接从内存中加载，在内存中加载的时候，如果太多会导致OOM，所以使用软引用来保存缓存数据。创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。PS：图片编辑器，视频编辑器之类的软件可以使用这种思路。


弱引用（Weak Reference） 发生GC时必定回收弱引用指向的内存空间。 和软引用加入队列的时机相同

应用场景：

Java源码中的java.util.WeakHashMap中的key就是使用弱引用，我的理解就是，一旦我不需要某个引用，JVM会自动帮我处理它，这样我就不需要做其它操作。弱引用常用于Map数据结构中，引用占用空间内存较大的对象。 

虚引用（Phantom Reference) 又称为幽灵引用或幻影引用，虚引用既不会影响对象的生命周期，也无法通过虚引用来获取对象实例，仅用于在发生GC时接收一个系统通知。 当一个对象的finalize方法已经被调用了之后，这个对象的幽灵引用会被加入到队列中。通过检查该队列里面的内容就知道一个对象是不是已经准备要被回收了. 虚引用和软引用和弱引用都不同,它会在内存没有清理的时候被加入引用队列.虚引用的建立必须要传入引用队列,其他可以没有

应用场景：

他的构造方法必须传递RefenceQueue参数，当GC准备回收一个对象时，发现它还有虚引用，就会在回收前，把虚引用加入到引用队列中，程序可以通过判断队列中是否加入虚引用来判断被引用的对象是否将要GC回收，从而可以在finalize方法中采取措施。

----------------------------------------------------------------------------------------------------------------------------------------

#### Hashcode的作用。

http://c610367182.iteye.com/blog/1930676

以Java.lang.Object来理解,JVM每new一个Object,它都会将这个Object丢到一个Hash哈希表中去,这样的话,下次做Object的比较或者取这个对象的时候,它会根据对象的hashcode再从Hash表中取这个对象。这样做的目的是提高取对象的效率。具体过程是这样:

new Object(),JVM根据这个对象的Hashcode值,放入到对应的Hash表对应的Key上,如果不同的对象确产生了相同的hash值,也就是发生了Hash key相同导致冲突的情况,那么就在这个Hash key的地方产生一个链表,将所有产生相同hashcode的对象放到这个单链表上去,串在一起。

比较两个对象的时候,首先根据他们的hashcode去hash表中找他的对象,当两个对象的hashcode相同,那么就是说他们这两个对象放在Hash表中的同一个key上,那么他们一定在这个key上的链表上。那么此时就只能根据Object的equal方法来比较这个对象是否equal。当两个对象的hashcode不同的话，肯定他们不能equal.

----------------------------------------------------------------------------------------------------------------------------------------

#### String、StringBuffer与StringBuilder的区别。

Java 平台提供了两种类型的字符串：String和StringBuffer / StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer和StringBulder类表示的字符串对象可以直接进行修改。StringBuilder是JDK1.5引入的，它和StringBuffer的方法完全相同，区别在于它是单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer略高。

----------------------------------------------------------------------------------------------------------------------------------------

#### Excption与Error区别

Error表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的状况；
Exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况

----------------------------------------------------------------------------------------------------------------------------------------

#### OOM：

1.OutOfMemoryError异常

除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(OOM)异常的可能，

Java Heap 溢出

一般的异常信息：java.lang.OutOfMemoryError:Java heap spacess

java堆用于存储对象实例，我们只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量达到最大堆容量限制后产生内存溢出异常。

出现这种异常，一般手段是先通过内存映像分析工具(如Eclipse Memory Analyzer)对dump出来的堆转存快照进行分析，重点是确认内存中的对象是否是必要的，先分清是因为内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)。

如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象时通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收。

如果不存在泄漏，那就应该检查虚拟机的参数(-Xmx与-Xms)的设置是否适当。

2.虚拟机栈和本地方法栈溢出

如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。

如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常

这里需要注意当栈的大小越大可分配的线程数就越少。

3.运行时常量池溢出

异常信息：java.lang.OutOfMemoryError:PermGen space

如果要向运行时常量池中添加内容，最简单的做法就是使用String.intern()这个Native方法。该方法的作用是：如果池中已经包含一个等于此String的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。由于常量池分配在方法区内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区的大小，从而间接限制其中常量池的容量。

4.方法区溢出

方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。

异常信息：java.lang.OutOfMemoryError:PermGen space

方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，判定条件是很苛刻的。在经常动态生成大量Class的应用中，要特别注意这点。

----------------------------------------------------------------------------------------------------------------------------------------

#### Java面向对象的三个特征与含义。

继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。

封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。

多态：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1. 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2. 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。

----------------------------------------------------------------------------------------------------------------------------------------

#### Interface与abstract类的区别。

抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。

总结：

1.抽象类是abstract修饰，接口是interface修饰

2.抽象类可以有任意类型的属性，接口只能有静态常量修饰的属性

3.抽象类可以有普通方法和抽象方法，接口的方法都是抽象的方法。

----------------------------------------------------------------------------------------------------------------------------------------

#### 反射机制

JAVA反射机制是在运行状态中, 对于任意一个类, 都能够知道这个类的所有属性和方法; 对于任意一个对象, 都能够调用它的任意一个方法和属性; 这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制.

主要作用有三：

运行时取得类的方法和字段的相关信息。

创建某个类的新实例(.newInstance())

取得字段引用直接获取和设置对象字段，无论访问修饰符是什么。

用处如下：

观察或操作应用程序的运行时行为。

调试或测试程序，因为可以直接访问方法、构造函数和成员字段。

通过名字调用不知道的方法并使用该信息来创建对象和调用方法。

----------------------------------------------------------------------------------------------------------------------------------------

#### 泛型的优缺点

优点：

使用泛型类型可以最大限度地重用代码、保护类型的安全以及提高性能。

泛型最常见的用途是创建集合类。

缺点：

在性能上不如数组快。

----------------------------------------------------------------------------------------------------------------------------------------

#### ArrayList、LinkedList、Vector的底层实现和区别

1.从同步性来看，ArrayList和LinkedList是不同步的，而Vector是的。所以线程安全的话，可以使用ArrayList或LinkedList，可以节省为同步而耗费的开销。但在多线程下，有时候就不得不使用Vector了。当然，也可以通过一些办法包装ArrayList、LinkedList，使我们也达到同步，但效率可能会有所降低。

2.从内部实现机制来讲ArrayList和Vector都是使用Object的数组形式来存储的。当你向这两种类型中增加元素的时候，如果元素的数目超出了内部数组目前的长度它们都需要扩展内部数组的长度，Vector缺省情况下自动增长原来一倍的数组长度，ArrayList是原来的50%，所以最后你获得的这个集合所占的空间总是比你实际需要的要大。如果你要在集合中保存大量的数据，那么使用Vector有一些优势，因为你可以通过设置集合的初始化大小来避免不必要的资源开销。

3.ArrayList和Vector中，从指定的位置（用index）检索一个对象，或在集合的末尾插入、删除一个对象的时间是一样的，可表示为O(1)。但是，如果在集合的其他位置增加或者删除元素那么花费的时间会呈线性增长O(n-i)，其中n代表集合中元素的个数，i代表元素增加或移除元素的索引位置，因为在进行上述操作的时候集合中第i和第i个元素之后的所有元素都要执行(n-i)个对象的位移操作。LinkedList底层是由双向循环链表实现的，LinkedList在插入、删除集合中任何位置的元素所花费的时间都是一样的O(1)，但它在索引一个元素的时候比较慢，为O(i)，其中i是索引的位置，如果只是查找特定位置的元素或只在集合的末端增加、移除元素，那么使用Vector或ArrayList都可以。如果是对其它指定位置的插入、删除操作，最好选择LinkedList。

----------------------------------------------------------------------------------------------------------------------------------------

#### HashMap和HashTable的底层实现和区别，两者和ConcurrentHashMap的区别。

http://blog.csdn.net/xuefeng0707/article/details/40834595

HashTable线程安全则是依靠方法简单粗暴的sychronized修饰，HashMap则没有相关的线程安全问题考虑。。

在以前的版本貌似ConcurrentHashMap引入了一个“分段锁”的概念，具体可以理解为把一个大的Map拆分成N个小的HashTable，根据key.hashCode()来决定把key放到哪个HashTable中。在ConcurrentHashMap中，就是把Map分成了N个Segment，put和get的时候，都是现根据key.hashCode()算出放到哪个Segment中。

通过把整个Map分为N个Segment（类似HashTable），可以提供相同的线程安全，但是效率提升N倍。

----------------------------------------------------------------------------------------------------------------------------------------

#### Map、Set、List、Queue、Stack的特点与用法。

http://www.cnblogs.com/yumo/p/4908718.html

Collection 是对象集合， Collection 有两个子接口 List 和 Set

List 可以通过下标 (1,2..) 来取得值，值可以重复

而 Set 只能通过游标来取值，并且值是不能重复的

ArrayList ， Vector ， LinkedList 是 List 的实现类

ArrayList 是线程不安全的， Vector 是线程安全的，这两个类底层都是由数组实现的

LinkedList 是线程不安全的，底层是由链表实现的

Map 是键值对集合

HashTable 和 HashMap 是 Map 的实现类
HashTable 是线程安全的，不能存储 null 值
HashMap 不是线程安全的，可以存储 null 值

Stack类：继承自Vector，实现一个后进先出的栈。提供了几个基本方法，push、pop、peak、empty、search等。

Queue接口：提供了几个基本方法，offer、poll、peek等。已知实现类有LinkedList、PriorityQueue等。

----------------------------------------------------------------------------------------------------------------------------------------

#### Synchronized 和Lock的区别

1.synchronized是关键字，lock是接口

2.Synchronized发生异常时，会自动释放县城占有的锁，不会发生死锁。lock发生异常时，若没有主动通过unlock()释放锁，很可能发生死锁，所以使用lock的时候，要在finally中释放锁。

3.lock可以知道是否成功获得锁，s不行。

----------------------------------------------------------------------------------------------------------------------------------------
#### Synchronized和volatile的区别

1.V本质是告诉jvm当前变量在工作内存中的值是不确定的，需要从主存中获取，而S是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞。

2.V仅能使用在变量级别，而S这可以使用在变量、方法、类级别中。

3.V不会造成线程阻塞，S会造成线程阻塞。

----------------------------------------------------------------------------------------------------------------------------------------

#### hashmap实现原理

底层使用hash表（数组+链表）当链表过长会将链表转为红黑树以实现O（logn）时间复杂度内查找

1.数组+链表+红黑树

2.数组的初始大小是16，最大值是2的30次方，扩容因子：0.75

3.链表的初始大小是8，即：当链表的大小达到8的时候，会自动转为红黑树的结构，目的是为了方便查找，在lgn的复杂度内

4.数组的初始大小是16，当当前的数据>16*0.75=12的时候，就会调用resize()的方法进行二倍的扩容（newCap=oldCap<<1）,将原来旧数组中的直接放在新数组中的对应位置 即newTab[j+oldCap]=hHead;  原下标+原容量的位置


#### 说一下put()的原理？

当我们使用put()的时候，会调用putVal(Hash(key),key,value,...)

1.先根据key计算hash值，然后再计算下标。这里这样计算的，int h;(int 类型是32位)，return (key==null)?0:(h=key.hashcode())^(h>>>16)

 这里注意一下：最后为什么要向右移16位，而不是直接计算hashcode值？
 
 首先我们计算得到的hashcode值是非常大的，而我们的数组不会是那么大的
 其次，向右移动16位，原先的int类型的是32位，右移16位后，32位的16个低位就没有了，这个时候，在用完整的hash跟剩下的高位16位进行异或能够充分利用高低位来计算，，然后达到缩小范围，使其尽可能分散，不集中，避免hash碰撞。
 
 2.把得到的hash值传入putVal()中----根据hash值，计算数组中的位置
 
    a.首先判断Tab数组是不是空→resize()→不是进行扩容，而是进行数组的初始化16
    b.根据hash值判断在数组中的位置，通过Tab[i=(n-1)&hash]
    注意这里获取地址是通过与运算，而不是直接的取模求余，为什么？
    其实这里面的(n-1)&hash  =   hash %n,之所以这么写，是因为位运算更快。
    n-1 也是有很大的学问？数组的长度都是2的n次幂，那么气二进制表示一定是10000000...这样类型的，那么n-1就会出现01111111....这样类型的
    然后与hash进行&运算，就会得到<=数组的长度，也就是能够保证最大值0-15，上一步已经保证尽可能随机化，这里进行与运算，也达到了尽可能分散。
    
3.放入桶中，如果没有碰撞，直接放入桶中。
 
4.如果碰撞了，以链表的方式连接到后面。
 
5.当不断向里面put的时候，当链表中元素的个数>8的时候，就会自动转为红黑树的存储，当我们不断的去除结点，当红黑树的节点数<6的时候，就又会转为链表形式。

6.如果桶满了，就需要扩容resize();
 
----------------------------------------------------------------------------------------------------------------------------------------
#### 如何实现Arraylist的add方法，插入时数组满了怎么办，扩容的话新数组是多大?

ArrayList是基于数组实现的，新增元素默认添加到数组的尾部，插入时数组满了会自动扩容，新数组是旧数组的1.5倍。

下面为add（）方法的源码，其中size指的是数组中存放元素的个数，elementData.length表示数组的长度，当new一个ArrayList系统默认产生一个长度为10的elementData数组，elementData.length=10，但是由于elementData中还未放任何元素所有size=0。如果加入元素后数组大小不够会先进行扩容，每次扩容都将数组大小增大一半，比如数组大小为10一次扩容后的大小为10+5=10;ArrayList的最大长度为 2^32 

----------------------------------------------------------------------------------------------------------------------------------------

#### JVM内存模型，内存中有什么?

内存中分为5个部分，其中线程私有的是程序计数器，java虚拟栈，本地方法栈，共享的是堆和方法区。

程序计数器 ：多线程时，当线程数超过CPU数量或CPU内核数量，线程之间就要根据时间片轮询抢夺CPU时间资源。因此每个线程有要有一个独立的程序计数器，记录下一条要运行的指令。线程私有的内存区域。如果执行的是JAVA方法，计数器记录正在执行的java字节码地址，如果执行的是native方法，则计数器为空。

虚拟机栈： 线程私有的，与线程在同一时间创建。管理JAVA方法执行的内存模型。每个方法执行时都会创建一个桢栈来存储方法的的变量表、操作数栈、动态链接方法、返回值、返回地址等信息。栈的大小决定了方法调用的可达深度（递归多少层次，或嵌套调用多少层其他方法，-Xss参数可以设置虚拟机栈大小）。栈的大小可以是固定的，或者是动态扩展的。如果请求的栈深度大于最大可用深度，则抛出stackOverflowError；如果栈是可动态扩展的，但没有内存空间支持扩展，则抛出OutofMemoryError。

本地方法区： 和虚拟机栈功能相似，但管理的不是JAVA方法，是本地方法，本地方法是用C实现的。

JAVA堆： 线程共享的，存放所有对象实例和数组。垃圾回收的主要区域。可以分为新生代和老年代(tenured)。
新生代用于存放刚创建的对象以及年轻的对象，如果对象一直没有被回收，生存得足够长，年轻对象就会被移入老年代。
新生代又可进一步细分为eden、survivorSpace0(s0,from space)、survivorSpace1(s1,to
space)。刚创建的对象都放入eden,s0和s1都至少经过一次GC并幸存。如果幸存对象经过一定时间仍存在，则进入老年代(tenured)。

方法区： 线程共享的，用于存放被虚拟机加载的类的元数据信息：如常量、静态变量、即时编译器编译后的代码。也成为永久代。如果hotspot虚拟机确定一个类的定义信息不会被使用，也会将其回收。回收的基本条件至少有：所有该类的实例被回收，而且装载该类的ClassLoader被回收

----------------------------------------------------------------------------------------------------------------------------------------

#### ConcurrentHashMap的设计原理？https://blog.csdn.net/zlfprogram/article/details/77524326

ConcurrentHashMap采用了分段锁的设计，只有在同一个分段内才存在竞态关系，不同的分段锁之间没有锁竞争。相比于对整个Map加锁的设计，分段锁大大的提高了高并发环境下的处理能力
ConcurrentHashMap中对这个数据结构，针对并发稍微做了一点调整。
它把区间按照并发级别(concurrentLevel)，分成了若干个segment。默认情况下内部按并发级别为16来创建。对于每个segment的容量，默认情况也是16。当然并发级别(concurrentLevel)和每个段(segment)的初始容量都是可以通过构造函数设定的。

![](https://github.com/MengZhao2017/mianshi/raw/master/res/Q137.png)

----------------------------------------------------------------------------------------------------------------------------------------

#### 进程和线程

1、进程是什么？
是具有一定独立功能的程序、它是系统进行资源分配和调度的一个独立单位，重点在系统调度和单独的单位，也就是说进程是可以独 立运行的一段程序。

2、线程又是什么？
线程是进程的一个实体，是CPU调度和分派的基本单位，他是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源。
在运行时，只是暂用一些计数器、寄存器和栈 。

他们之间的关系

1、一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程（通常说的主线程）。

2、资源分配给进程，同一进程的所有线程共享该进程的所有资源。

3、线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。

4、处理机分给线程，即真正在处理机上运行的是线程。

5、线程是指进程内的一个执行单元，也是进程内的可调度实体。 

从三个角度来剖析二者之间的区别

1、调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。

2、并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行。

3、拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。

----------------------------------------------------------------------------------------------------------------------------------------

#### java进程之间通信方式?
（1）管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。

（2）命名管道（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关 系 进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。

（3）信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送 信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。

（4）消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺

（5）共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。

（6）内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。

（7）信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。

（8）套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。

----------------------------------------------------------------------------------------------------------------------------------------

#### java线程之间通信方式？https://blog.csdn.net/ls5718/article/details/51878770

1、共享变量

线程间发送信号的一个简单方式是在共享对象的变量里设置信号值。线程A在一个同步块里设置boolean型成员变量hasDataToProcess为true，线程B也在同步块里读取hasDataToProcess这个成员变量。这个简单的例子使用了一个持有信号的对象，并提供了set和check方法:

2、wait/notify机制

为了实现线程通信，我们可以使用Object类提供的wait()、notify()、notifyAll()三个方法。调用wait()方法会释放对该同步监视器的锁定。这三个方法必须由同步监视器对象来调用，这可分成两种情况：
对于使用synchronized修饰的同步方法，因为该类的默认实例是(this)就是同步监视器，所以可以直接调用这三使用个方法。
对于synchronized修饰的同步代码块，同步监视器是synchronized括号里的对象，所以必须使用该对象调用这三个方法。

3、Lock/Condition机制

如何程序不使用synchronized关键字来保持同步，而是直接适用Lock对像来保持同步，则系统中不存在隐式的同步监视器对象，也就不能使用wait()、notify()、notifyAll()来协调线程的运行.

当使用LOCK对象保持同步时，JAVA为我们提供了Condition类来协调线程的运行。关于Condition类，JDK文档里进行了详细的解释.，再次就不啰嗦了。

4、管道

管道流是JAVA中线程通讯的常用方式之一，基本流程如下：

1）创建管道输出流PipedOutputStream pos和管道输入流PipedInputStream pis

2）将pos和pis匹配，pos.connect(pis);

3）将pos赋给信息输入线程，pis赋给信息获取线程，就可以实现线程间的通讯了


----------------------------------------------------------------------------------------------------------------------------------------

#### get和post的区别

1.get是从服务器上获取数据，post是向服务器传送数据

2.get是吧参数放在URL中，post是把参数放在http包体内

3.get传送的数据量较小，不能大于2kb，post较大，一般不受限制

4.get效率高，安全性低，post相反

----------------------------------------------------------------------------------------------------------------------------------------

#### java的单例模式

懒汉：

       public class Singleton{
              private static Singleton s;
              private Singleton(){};
              public static sychronized Singleton getS()
              {
                   if(s==null)
                   {
                     s=new Singleton();
                   }
                   return s;
              }
              }

饿汉：

       public class Singleton{
          private static final Singleton s=new Singleton();
            private Singleton(){};
            public static  Singleton getS()
            {
               return s;
            }
         }

----------------------------------------------------------------------------------------------------------------------------------------

#### sleep和wait区别

1.sleep是Thread的类方法，wait是object类

2.sleep是自动唤醒，wait要等待其他线程来唤醒

3.sleep不会释放同步锁，wait会释放

4.sleep可以在任意方法中，wait只能在同步块中

----------------------------------------------------------------------------------------------------------------------------------------

#### 什么是死锁：

所谓死锁是指多个线程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。

产生的原因：

1) 系统资源的竞争

通常系统中拥有的不可剥夺资源，其数量不足以满足多个进程运行的需要，使得进程在 运行过程中，会因争夺资源而陷入僵局，如磁带机、打印机等。只有对不可剥夺资源的竞争 才可能产生死锁，对可剥夺资源的竞争是不会引起死锁的。

2) 进程推进顺序非法

进程在运行过程中，请求和释放资源的顺序不当，也同样会导致死锁。例如，并发进程 P1、P2分别保持了资源R1、R2，而进程P1申请资源R2，进程P2申请资源R1时，两者都 会因为所需资源被占用而阻塞。

3）死锁产生的必要条件

1.互斥条件：同一时间，某个资源只能由一个进程占用

2.占有并等待

3.不可剥夺： 未使用完成前，不能被剥夺

4.环路等待

处理死锁的方法：

1.预防死锁
2.避免死锁
3.检测死锁
4.解除死锁

解决死锁：
第一个是死锁预防，就是不让上面的四个条件同时成立。

二是，合理分配资源。

三是使用银行家算法，如果该进程请求的资源操作系统剩余量可以满足，那么就分配。

----------------------------------------------------------------------------------------------------------------------------------------

#### ThreadLocal 原理介绍：https://blog.csdn.net/mccand1234/article/details/54173084

ThreadLocal是一个关于创建线程局部变量的类。
通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。而使用ThreadLocal创建的变量只能被当前线程访问，其他线程则无法访问和修改。

就是为每一个使用该变量的线程都提供一个变量值的副本，是每一个线程都可以独立改变自己的副本，而不会和其他线程的副本产生冲突

ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。

可以总结为一句话：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。 
举个例子，我出门需要先坐公交再做地铁，这里的坐公交和坐地铁就好比是同一个线程内的两个函数，我就是一个线程，我要完成这两个函数都需要同一个东西：公交卡（北京公交和地铁都使用公交卡），那么我为了不向这两个函数都传递公交卡这个变量（相当于不是一直带着公交卡上路），我可以这么做：将公交卡事先交给一个机构，当我需要刷卡的时候再向这个机构要公交卡（当然每次拿的都是同一张公交卡）。这样就能达到只要是我(同一个线程)需要公交卡，何时何地都能向这个机构要的目的。

public T get() { }

public void set(T value) { }

public void remove() { }

protected T initialValue() { }

get()方法是用来获取ThreadLocal在当前线程中保存的变量副本，set()用来设置当前线程中变量的副本，remove()用来移除当前线程中变量的副本，

initialValue()是一个protected方法，一般是用来在使用时进行重写的，它是一个延迟加载方法，下面会详细说明。

----------------------------------------------------------------------------------------------------------------------------------------

#### ThreadLocal 与synchronized对比：

1.都是解决线程同步问题

2.synchronized修饰：线程将排队访问变量，以时间换空间；threadloca修饰：会为每个线程创建一个副本，以空间换时间

3.synchronized修饰:每个线程的调用后对变量的修改都是有影响的；threadloca修饰：线程之间对变量的修改互不影响，各自持有变量的副本

----------------------------------------------------------------------------------------------------------------------------------------

#### volatile关键字剖析？

volatile关键字的两层语义

一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：

1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。

如何保证可见性的呢

1.当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。

2.当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。

2）禁止进行指令重排序。

     volatile关键字禁止指令重排序有两层意思：
       1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；

       2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。


----------------------------------------------------------------------------------------------------------------------------------------

#### java内存模型概述

JMM本身是一种抽象的概念，并不是真实存在的，它描述的是一种规则或者规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和数组）的访问方式，由于jvm运行程序的实体是线程，而每个线程创建时jvm都会为其创建一个工作内存，用于存储线程的私有数据，而java内存模型规定所有变量都必须存在主内存，主内存是共享内存区域，所有线程都可以进行访问，但线程对变量的操作（读取 赋值等）必须在工作内存中完成。

首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后，再将变量写回主内存，不能直接操作主内存中的变量，工作内存存储着主内存中的变量拷贝副本。

----------------------------------------------------------------------------------------------------------------------------------------

#### 为什么一般重写equals()的时候，要重写hashcode()?


1.若重写了equals()但未重写hashCode(),会违反约定：相等的对象必须要有相同的散列码（hashcode）。

2.对于基于hash实现的类，如HashSet，HashMap，若不重写hashCode()，会导致这些类不能正常使用。原因是：HashMap底层是数组，其下标是传入元素的hashCode和特定值异或决定的。若该数组位置上有值且键值相等，则不处理；若不等则覆盖；若该位置为空，则插入并加入到响应链表中。检查键是否存在也是由hashCode值确定的

----------------------------------------------------------------------------------------------------------------------------------------

#### java 中线程池

线程池：在程序启动的时候就创建若干线程来响应处理。池里存放的是工作线程。

作用：
一.降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。

二.提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
     
三.提高线程的可管理性。

常用线程池：ExecutorService 是主要的实现类，其中常用的有 

Executors.newSingleThreadPool()

newFixedThreadPool()

newcachedTheadPool()

newScheduledThreadPool()

----------------------------------------------------------------------------------------------------------------------------------------

#### java 中泛型  https://blog.csdn.net/sunxianghuang/article/details/51982979

1. Java中的泛型是什么 ? 使用泛型的好处是什么?

泛型是一种参数化类型的机制。它可以使得代码适用于各种类型，从而编写更加通用的代码，例如集合框架

泛型是一种编译时类型确认机制。它提供了编译期的类型安全，确保在泛型类型（通常为泛型集合）上只能使用正确类型的对象，避免了在运行时出现ClassCastException。

主要优点：是能够在编译时而不是在运行时检测出错误。

举个例子：
Comparable  c=new Date();
System.out.println(c.compareTo("red"));//这样的代码是可以编译的，但是会产生一个运行时的错误。因为字符串不可能和Data对象进行比较

Comparable <Data>  c=new Date();
System.out.println(c.compareTo("red"));//这样的代码在编译的时候就会出现错误，因此泛型是程序更加可靠。
 
 泛型类型必须是引用类型，不能使用int，double或者char这样的基本类型，应该是Integer，Double，Character等

2.Java的泛型是如何工作的 ? 什么是类型擦除 ?

泛型的正常工作是依赖编译器在编译源码的时候，先进行类型检查，然后进行类型擦除并且在类型参数出现的地方插入强制转换的相关指令实现的。

编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如List<String>在运行时仅用一个List类型来表示。为什么要进行擦除呢？这是为了避免类型膨胀。

3. 什么是泛型中的限定通配符和非限定通配符 ?

限定通配符对类型进行了限制。有两种限定通配符，一种是<? extends T>它通过确保类型必须是T的子类来设定类型的上界，另一种是<? super T>它通过确保类型必须是T的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面<?>表示了非限定通配符，因为<?>可以用任意类型来替代。

4. List<? extends T>和List <? super T>之间有什么区别 ?

这和上一个面试题有联系，有时面试官会用这个问题来评估你对泛型的理解，而不是直接问你什么是限定通配符和非限定通配符。这两个List的声明都是限定通配符的例子，List<? extends T>可以接受任何继承自T的类型的List，而List<? super T>可以接受任何T的父类构成的List。例如List<? extends Number>可以接受List<Integer>或List<Float>。在本段出现的连接中可以找到更多信息。
 
 5.Java中List<?>和List<Object>之间的区别是什么?
 
这道题跟上一道题看起来很像，实质上却完全不同。List<?> 是一个未知类型的List，而List<Object>其实是任意类型的List。你可以把List<String>, List<Integer>赋值给List<?>，却不能把List<String>赋值给List<Object>。   

----------------------------------------------------------------------------------------------------------------------------------------

#### Java是如何实现跨平台的？

跨平台是怎样实现的呢？这就要谈及Java虚拟机（Java Virtual Machine，简称 JVM）。

JVM也是一个软件，不同的平台有不同的版本。我们编写的Java源码，编译后会生成一种 .class 文件，称为字节码文件。Java虚拟机就是负责将字节码文件翻译成特定平台下的机器码然后运行。也就是说，只要在不同平台上安装对应的JVM，就可以运行字节码文件，运行我们编写的Java程序。

而这个过程中，我们编写的Java程序没有做任何改变，仅仅是通过JVM这一”中间层“，就能在不同平台上运行，真正实现了”一次编译，到处运行“的目的。
JVM是一个”桥梁“，是一个”中间件“，是实现跨平台的关键，Java代码首先被编译成字节码文件，再由JVM将字节码文件翻译成机器语言，从而达到运行Java程序的目的。
注意：编译的结果不是生成机器码，而是生成字节码，字节码不能直接运行，必须通过JVM翻译成机器码才能运行。不同平台下编译生成的字节码是一样的，但是由JVM翻译成的机器码却不一样。

所以，运行Java程序必须有JVM的支持，因为编译的结果不是机器码，必须要经过JVM的再次翻译才能执行。即使你将Java程序打包成可执行文件（例如 .exe），仍然需要JVM的支持。

注意：跨平台的是Java程序，不是JVM。JVM是用C/C++开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的JVM。

----------------------------------------------------------------------------------------------------------------------------------------

#### 手机扫二维码登录是怎么实现的？ https://www.jianshu.com/p/7f072ac61763

①：用户 A 访问微信网页版，微信服务器为这个会话生成一个全局唯一的 ID，上面的 URL 中 obsbQ-Dzag== 就是这个 ID，此时系统并不知道访问者是谁。

②：用户A打开自己的手机微信并扫描这个二维码，并提示用户是否确认登录。

③：手机上的微信是登录状态，用户点击确认登录后，手机上的微信客户端将微信账号和这个扫描得到的 ID 一起提交到服务器

④：服务器将这个 ID 和用户 A 的微信号绑定在一起，并通知网页版微信，这个 ID 对应的微信号为用户 A，网页版微信加载用户 A 的微信信息，至此，扫码登录全部流程完成

----------------------------------------------------------------------------------------------------------------------------------------

#### Java 线程有哪些状态，这些状态之间是如何转化的？

新建(new)：新创建了一个线程对象。

可运行(runnable)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。

运行(running)：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。

阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种：

(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。

(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。

(三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。

死亡(dead)：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。

当然有的时候也会说七种状态，那就是除了上面的五种状态外，再加上等待队列（等待阻塞）、和锁池（同步阻塞）。

----------------------------------------------------------------------------------------------------------------------------------------

#### 通过反射机制获取类对象方法与区别

1.Class c1=Class.forName("cn.test.Demo");

2.Class c2=Demo.class;

3.Class c3=new Demo().getClass();

区别：

c1 方式会让 ClassLoader 进行类加载然后进行类的初始化。

c2 方式会让 ClassLoader 进行类加载但是不初始化。

c3 方式获取的是已经被加载且初始化过后实例化运行中类的 Class 实例。

简单说说 Java Class.newInstance() 与 Constructor.newInstance() 方法区别？

调用 Class 对象的 newInstance 方法会调用对象的默认构造方法，如果没有默认构造方法就会异常调用失败。而调用 Constructor 对象的 newInstance 方法可以选择要不要传递参数，没有参数时就类似 Class 的 newInstance，有参数时就调用对应有参构造方法。

----------------------------------------------------------------------------------------------------------------------------------------

#### ReentrantLock:

ReentrantLock→Lock
ReentrantLocky 拥有与 Synchronized相同的并发性和内存语义，但是添加了类似的锁投票，定时锁等候和可中断锁等候的一些特性。

1.Synchronized只支持单条件，比如10个线程都在等候Synchronized块锁定的资源，如果一直锁定，则其他线程都得不到释放而引起死锁，同样情况下，ReentrantLock则允许其他线程中断放弃尝试，可以指定notify某个线程。

2.ReentrantLock可以成为公平锁，即让等待最长时间的线程最早获得该锁，（获得锁的顺序和申请锁的顺序是一致的），与之对应的Synchronized是非公平的，当然ReentrantLock也可以是非公平的。

3.ReentrantLock又叫可重入锁，也就是说一个线程拥有锁之后，可以再次确认是否持有锁而不会出现死锁问题。

Synchronized是依赖于JVM实现的，而ReenTrantLock是JDK实现的，有什么区别，说白了就类似于操作系统来控制实现和用户自己敲代码实现的区别。前者的实现是比较难见到的，后者有直接的源码可供阅读。

ReenTrantLock独有的能力：

1.ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。

2.ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。

3.ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。

----------------------------------------------------------------------------------------------------------------------------------------

#### BIO和NIO   https://blog.csdn.net/scythe666/article/details/51981846   https://blog.csdn.net/anxpp/article/details/51512200

同步、异步：

概念：消息的通知机制

解释：涉及到IO通知机制；所谓同步，就是发起调用后，被调用者处理消息，必须等处理完才直接返回结果，没处理完之前是不返回的，调用者主动等待结果；所谓异步，就是发起调用后，被调用者直接返回，但是并没有返回结果，等处理完消息后，通过状态、通知或者回调函数来通知调用者，调用者被动接收结果。

阻塞、非阻塞：

概念：程序等待调用结果时的状态

解释：涉及到CPU线程调度；所谓阻塞，就是调用结果返回之前，该执行线程会被挂起，不释放CPU执行权，线程不能做其它事情，只能等待，只有等到调用结果返回了，才能接着往下执行；所谓非阻塞，就是在没有获取调用结果时，不是一直等待，线程可以往下执行，如果是同步的，通过轮询的方式检查有没有调用结果返回，如果是异步的，会通知回调。

同步：就是一个任务的完成需要依赖另外一个任务，只有等待被依赖的任务完成后，依赖任务才能完成。

异步：不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，只要自己任务完成了就算完成了，被依赖的任务是否完成会通知回来。（异步的特点就是通知）。 打电话和发短信来比喻同步和异步操作。

阻塞：CPU停下来等一个慢的操作完成以后，才会接着完成其他的工作。

非阻塞：非阻塞就是在这个慢的执行时，CPU去做其他工作，等这个慢的完成后，CPU才会接着完成后续的操作。非阻塞会造成线程切换增加，增加CPU的使用时间能不能补偿系统的切换成本需要考虑。

经典故事案例：
人物：老张

道具：普通水壶（水烧开不响）；响水壶（水烧开发出响声）

案例：
        1、同步阻塞：
              老张在厨房用普通水壶烧水，一直在厨房等着（阻塞），盯到水烧开（同步）；
        2、异步阻塞：
              老张在厨房用响水壶烧水，一直在厨房中等着（阻塞），直到水壶发出响声（异步），老张知道水烧开了；
        3、同步非阻塞：
              老张在厨房用普通水壶烧水，在烧水过程中，就到客厅去看电视（非阻塞），然后时不时去厨房看看水烧开了没                                               （轮询检查同步结果）；
        4、异步非阻塞：
              老张在厨房用响水壶烧水，在烧水过程中，就到客厅去看电视（非阻塞），当水壶发出响声（异步），老张就知道水烧开了。                           
BIO(Blocking I/O)

在Java中，BIO是基于流的，这个流包括字节流或者字符流，基本上所有的流都是单向的，要么只读，要么只写。在实际上编程时，在对IO操作之前，要先获取输入流或输出流，然后对输入流读或对输出流写即完成实际的IO读写操作。 首先需要新建一个ServerSocket对象监听特定端口，然后当有客户端的连接请求到来时，在服务器端获取一个Socket对象，用来进行实际的通信。

BIO的编程模型简单易行，但是缺点也很明显。由于采用的是同步阻塞IO的模式，所以server端要为每一个连接创建一个线程，一方面，线程之间在进行上下文切换的时候会造成比较大的开销，另一方面，当连接数过多时，可能会造成服务器崩溃的现象产生。

为了解决这个问题？提出了NIO？

NIO主要有三部分组成：Channel，Selector,Buffer

为了解决这个问题，在JDK 1.4的时候，引入了NIO（New IO）的概念。NIO主要由三个部分组成，即Channel，Buffer和Selector。Channel可以跟BIO中的Stream类比，不同的是Channel是可读可写的。当和Channel进行交互的时候需要Buffer的支持，数据可以从Buffer写到Channel中，也可以从Channel中读到Buffer中。

NIO中另一个重要的组件是Selector，Selector可以用来检查一个或多个Channel是否有新的数据到来，这种方式可以实现在一个线程中管理多个Channel的目的。

AIO(Asynchronous I/O)

在JDK 1.7时，Java引入了AIO的概念，AIO还是基于Channel和Buffer的，不同的是它是异步的。用户线程把实际的IO操作以及数据拷贝全部委托给内核来做，用户只要传递给内核一个用于存储数据的地址空间即可。内核处理的结果通过两种方式返回给用户线程。一是通过Future对象，另外一种是通过回调函数的方式，回调函数需要实现CompletionHandler接口。

----------------------------------------------------------------------------------------------------------------------------------------

#### NIO和IO的区别

第一点，NIO少了1次从内核空间到用户空间的拷贝。

ByteBuffer.allocateDirect()分配的内存使用的是本机内存而不是Java堆上的内存，和网络或者磁盘交互都在操作系统的内核空间中发生。allocateDirect()的区别在于这块内存不由java堆管理, 但仍然在同一用户进程内。

第二点，NIO以块处理数据，IO以流处理数据

第三点，非阻塞，NIO1个线程可以管理多个输入输出通道

----------------------------------------------------------------------------------------------------------------------------------------

#### 线程中sleep()和yield()的区别

1.sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会，但是yield()方法只会给相同优先级的线程以运行的机会。

2.线程执行sleep()方法后转入阻塞状态，而执行yield()方法后转入就绪状态

3.sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常

----------------------------------------------------------------------------------------------------------------------------------------

#### java中序列化

序列化就是一种用来处理对象流的机制，所谓的对象流就是将对象的内容进行流化，可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间，序列化是为了解决对象流读写操作时可能引发的问题（如果不序列化可能会存在数据乱序的问题）

要实现序列化，需要让一个类实现Serializable接口i，该接口是一个标示性的接口，标注该类是可以被序列化的，，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将实现对象写出。

----------------------------------------------------------------------------------------------------------------------------------------

#### 如何通过反射创建对象

1.通过类对象调用newInstance()方法，例如String.class.newInstance()

2.通过类对象的getConstructor()或者getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象

例如：String.class.getConstructor(String.class).newInstance("hello");

----------------------------------------------------------------------------------------------------------------------------------------

#### java中内部类

内部类主要分为四个部分：

成员内部类，局部内部类，匿名内部类，静态内部类

1.成员内部类

成员内部类也是最普通的内部类，它是外围类的一个成员，所以他是可以无限制的访问外围类的所有 成员属性和方法，尽管是private的，但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。

在成员内部类中要注意两点：

第一：成员内部类中不能存在任何static的变量和方法；

第二：成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。

2.局部内部类

有这样一种内部类，它是嵌套在方法和作用于内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。

3.匿名内部类

     public class OuterClass {
         public InnerClass getInnerClass(final int num,String str2){
             return new InnerClass(){
                 int number = num + 3;
                 public int getNumber(){
                     return number;
                 }
             };        /* 注意：分号不能省 */
         }

         public static void main(String[] args) {
             OuterClass out = new OuterClass();
             InnerClass inner = out.getInnerClass(2, "chenssy");
             System.out.println(inner.getNumber());
         }
     }

     interface InnerClass {
         int getNumber();
     }

     ----------------
     Output:
     5

这里我们就需要看清几个地方

        1、 匿名内部类是没有访问修饰符的。

         2、 new 匿名内部类，这个类首先是要存在的。如果我们将那个InnerClass接口注释掉，就会出现编译出错。

         3、 注意getInnerClass()方法的形参，第一个形参是用final修饰的，而第二个却没有。同时我们也发现第二个形参在匿名内部类中没有使用过，所以当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final。

        4、 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。


4.静态内部类

 在java提高篇-----关键字static中提到Static可以修饰成员变量、方法、代码块，其他它还可以修饰内部类，使用static修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着：

      1、 它的创建是不需要依赖于外围类的。

      2、 它不能使用任何外围类的非static成员变量和方法。
      
----------------------------------------------------------------------------------------------------------------------------------------

 类加载的过程，加载、验证、准备、解析、初始化。每个部分详细描述。

加载：

1.我们拿到这个类的全限定名，然后根据全限定名拿到二进制字节流

2.二进制字节流的静态数据结构转化成方法区的运行时数据结构（虚拟机所需要的格式：字节码）

3.生成Class对象

验证：

我们比如从apk的类中加载Java类，而不是在本地编译器里写，那么他的正确性就无法得到保证了。

1.文件格式验证（比如是否以魔数开头等）。只有通过这个验证，才能转化成字节码

2.字节码表达的内容是否符合Java语法？

3.字节码表达的语义是否合法？

4.对这个类以外的东西验证，比如我真的能访问到那个private类吗？

准备：

给static赋默认值，而非指定的值，初始化的时候才会这么做。这些内存是分配在方法区的。

解析：

符号引用替换为直接引用。怎么理解符号引用呢？比如我们A类想访问B类的某个方法，怎么定位它呢？所以B的字节码中对于那个方法就有一个符号引用。比如我们要访问一个类，怎么定位它的Class对象呢？这也需要解析。我们想访问他里面的一个字段，这也需要解析。

1.解析类/接口

2.解析字段

3.解析方法

4.解析接口方法

此外这个解析是有cache机制的。

初始化：

正式开始使用字节码。先对static变量进行赋值，再执行static代码块。父类的静态先执行。而接口的话就不是了，父子接口，实现与被实现，静态执行都没有必然的联系。

----------------------------------------------------------------------------------------------------------------------------------------

三种类加载器，如何自定义一个类加载器？

1.启动加载器：Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）

2.扩展加载器：Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap

3.应用程序加载器：System：其父类是Extension，他是应用最广泛的类加载器，它从环境变量classpath或者系统属性java.class.path所指定的目录中加载类，是用户自定义加载器的默认的父加载器。

自定义类加载器：重写findClass，并从中调用defineClass（把字节码转化成类）

----------------------------------------------------------------------------------------------------------------------------------------

 JVM锁的优化，偏向锁、轻量级锁概念及原理。

自旋——要请求一个对象，不会立刻挂起，而是先自旋一下，为了不频繁切换内核、用户态。无意义的锁，会被清除。分散的锁，会被合并。

偏向锁认为只有一个线程来访问他。如果A线程已经访问过他，B线程来访问了，会检查A死了没，如果死了那就开始偏向B了，如果没死，就膨胀为轻量级锁了。

轻量级认为竞争存在，一般会通过自旋来解决问题。如果自旋太多次或者自旋的时候，还有第三者插足，这个时候就膨胀为重量级锁了。

---------------------------------------------------------------------------------------------------------------------------------------

fail-fast机制

机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。

例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件

---------------------------------------------------------------------------------------------------------------------------------------

happens-before:

如果两个操作之间具有happens-before 关系，那么前一个操作的结果就会对后面一个操作可见。

1.程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。

2.监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。

3.volatile变量规则：对一个volatile域的写，happens- before于任意后续对这个volatile域的读。

4.传递性：如果A happens- before B，且B happens- before C，那么A happens- before C。

5.线程启动规则：Thread对象的start()方法happens- before于此线程的每一个动作。

---------------------------------------------------------------------------------------------------------------------------------------
CAS（Compare And Swap）无锁算法

CAS是乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。

---------------------------------------------------------------------------------------------------------------------------------------

java并发编程中锁：https://blog.csdn.net/qq442270636/article/details/80556657

1.公平锁、非公平锁

我们使用的 synchronized 关键字就是一宗非公平锁，ReentrantLock是一种可通过构造函数设置是否公平的锁，默认是非公平锁。公平锁是什么呢？
既然公平，那就是根据申请获取锁的顺序来获取锁，他的优点是不会造成饥饿现象。那么非公平锁就是不会按照顺序来获取锁，这种情况下吞吐量变大，但是会造成饥饿现象，某些线程可能永远获取不到锁。

通常我们为了提高网站的吞吐量都会设置非公平锁。大家有兴趣可以自己实现下公平锁，我也会单独发一篇自己实现的公平锁。

2.独享锁、共享锁

独享锁就不多说了，从名字就可看出来就是独占锁之后其他线程不能获取锁，ReentrantLock是一种独享锁。共享锁也叫读锁，在Java中有一个接口叫做ReadWriteLock。也就是读写锁，它是读写锁一种实现。这种锁不同于独享锁，读读之间互斥，写写之间互斥，读写互斥，也就是在读与读中锁是共享的。

3.分段锁

synchronized 的缺点是粒度比较粗，在HashTable是一个线程安全的集合，但是现在很少使用，在面试中有很多次问到我：为什么使用 ConcurrentHashMap，就是因为它里面使用的是分段锁，而不是锁住整个集合，它只是锁住部分段。在JDK1.8中ConcurrentHashMap取消了Segment分段锁的数据结构，取而代之的是数组+链表（红黑树）的结构。而对于锁的粒度，调整为对每个数组元素加锁（Node）链表（n>8时）替换成红黑树时防止链表深度过深,且ConcurrentHashMap采用无锁算法（CAS）解决并发问题，属于乐观锁的范围（不在过多叙述了，在后续集合篇中会继续聊，大家可以自己去查阅一些资料，因为在面试中，集合被问到的次数一点也不少于多线程）

4.乐观锁、悲观锁

乐观锁是认为不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 乐观锁不能解决脏读的问题。悲观锁：认为一定会并发冲突，出现资源的抢占，需要屏蔽一切可能违反数据完整性的操作。这种锁可以聊到很多方面的知识，比如数据库的行级锁，表级锁，悲观锁在数据update前对数据库加入行级锁，但是如果没用到索引就会变成表级锁，锁住整个表。再有就是乐观锁不能解决脏读可以联想到数据库的事物隔离级别分别解决事物并发问题：脏读，不可重复读，幻读。

5.自旋锁

自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。这种方式增加了CPU的消耗，但是减少了线程切换消耗。

---------------------------------------------------------------------------------------------------------------------------------------
说说你对 MVC、MVP、MVVM 的理解？
![](https://github.com/MengZhao2017/mianshi/raw/master/res/mvc-mvp-mvvm.png)


通过上图我们可以发现 MVC(Model-View-Controller)、MVP(Model-View-Presenter)、MVVM(Model-View-ViewModel) 的共同点是都具备独立的 Model 和 View，其中 Model 是数据对象，Model 不依赖于 View 的实现，而 View 是 UI 层，提供对最终用户的交互操作功能。而三者的差异主要提现在 Controller、Presenter、ViewModel 上。


Controller 会接收 View 的操作，然后根据操作调用 Model 的接口进行数据操作或进行 View 的跳转，所以一个 Controller 可以对应多个 View，Controller 对 View 实现不太关心，只会被动地接收，Model 的数据变化会不经过 Controller 而直接通知 View，一般 View 采用观察者模式监听 Model 的变化。

Presenter 与 Controller 类似，接收 View 的操作对 Model 进行操作，Presenter 会反作用于 View，Model 的数据变化首先会被 Presenter 获取，然后 Presenter 再去更新 View；一个 Presenter 只能对应一个 View，所以接口层代码会比较臃肿。

ViewModel 可以理解成是包含 View 的一些数据属性和操作的一种模型，View 的变化会直接影响 ViewModel，ViewModel 的变化或者内容也会直接体现在 View 上，ViewModel 与 Model 进行沟通操作；这种模式的核心就是数据绑定（Data Binding）。

---------------------------------------------------------------------------------------------------------------------------------------




---------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------------------








